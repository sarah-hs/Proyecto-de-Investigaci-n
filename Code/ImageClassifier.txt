typealias FileInfo = (name: String, extension: String)

enum Model {
	static let modelInfo: FileInfo = (name: "rock_model", extension: "tflite")
	static let labelsInfo: FileInfo = (name: "rock_labels", extension: "txt")
}

class ImageClassifier {
	private var interpreter: Interpreter
	private var inputShape: TensorShape
	private var outputShape: TensorShape
	private var resultsToDisplay = -1
	private var labels: [String] = []

	private func loadLabels(fileInfo: FileInfo) {
		*···*
	}
    
	fileprivate init(interpreter: Interpreter, inputShape: TensorShape, outputShape: TensorShape) {
		self.interpreter = interpreter
		self.inputShape = inputShape
		self.outputShape = outputShape
		self.loadLabels(fileInfo: Model.labelsInfo)
	}

	static func newInstance(completion: @escaping ((Result<ImageClassifier>) -> ())) {
		*···*
	}

	func classify(image: UIImage, completion: @escaping ((Result<String>) -> ())) {
		let inputTensor = try self.interpreter.input(at:0)
		guard let rgbData = image.scaledData(
			inputShape: self.inputShape,
			isModelQuantized: inputTensor.dataType == .uInt8
		)
		*···*
		try self.interpreter.copy(rgbData, toInputAt:0)
		try self.interpreter.invoke()
		outputTensor = try self.interpreter.output(at:0)
        		*···*
		let results: [Float]
		results = outputTensor.data.toArray(type: Float32.self)
		*···*
		let zippedResults = zip(self.labels.indices, results)
		let sortedResults = zippedResults.sorted {$0.1 > $1.1}.prefix(self.resultsToDisplay)
		let inferences =  sortedResults.map {
			result in Inference(confidence: result.1, label: self.labels[result.0])
		}
		var str_inferences = ""
		var first = true
		for inference in inferences {
			if (first){
				str_inferences += "\(inference.label): \(inference.confidence.truncate(places: 3))%"
				first = false
			} else {
				str_inferences += "\n\(inference.label): \(inference.confidence.truncate(places: 3))%"
			}
		}
		*···*
	}
}